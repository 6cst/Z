# -*- coding: utf-8 -*-
"""KNNxPANDAS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AekitY8EiJgTmOSEGzuGhWe09TH1tXWv
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report

# Step 1: Load dataset
df = pd.read_csv('/content/diabetes.csv')

# Step 2: Label Encode if any categorical columns
for col in df.select_dtypes(include='object').columns:
    le = LabelEncoder()
    df[col] = le.fit_transform(df[col])

# Step 2: Data Info
print(df.info())
print(df.head())
print(df.tail())
print(df.describe())
print("Missing values:\n", df.isnull().sum())
print("Duplicates:", df.duplicated().sum())

# Step 3: Statistical methods
print("Mean:\n", df.mean())
print("Median:\n", df.median())
print("Standard Deviation:\n", df.std())
print("Variance:\n", df.var())
print("Correlation:\n", df.corr())

# Step 4: Data Visualization
# Correlation heatmap
plt.figure(figsize=(10, 6))
sns.heatmap(df.corr(), annot=True, cmap="coolwarm")
plt.title("Correlation Heatmap")
plt.show()

# Histogram for outcome
plt.figure(figsize=(7, 4))
sns.countplot(x="Outcome", data=df, palette="Set2")
plt.title("Diabetes Outcome Count")
plt.show()

# Step 5: Data Splitting
X = df.drop(columns=["Outcome"])
y = df["Outcome"]

# Normalize Features
scaler = StandardScaler()
X = scaler.fit_transform(X)

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

from sklearn.neighbors import KNeighborsClassifier
# 8. Model Training
knn = KNeighborsClassifier(n_neighbors=18)
knn.fit(X_train, y_train)

# 9. Predictions and Confusion Matrix
y_pred = knn.predict(X_test)
print("Confusion Matrix:")
print(confusion_matrix(y_test, y_pred))

# 10. Accuracy, Precision, Recall, F1-Score
print("Classification Report:")
print(classification_report(y_test, y_pred))
print("Accuracy:", accuracy_score(y_test, y_pred))

# 11. Cross-validation
cv_scores = cross_val_score(knn, X, y, cv=5)
print("Cross-Validation Scores:", cv_scores)
print("Mean CV Accuracy:", np.mean(cv_scores))

# Step 9: Optimal K value using Error Rate
from sklearn.neighbors import KNeighborsClassifier
error_rate = []
k_range = range(1, 21)

for k in k_range:
    knn = KNeighborsClassifier(n_neighbors=k)
    knn.fit(X_train, y_train)
    pred_k = knn.predict(X_test)
    error_rate.append(np.mean(pred_k != y_test))

# Step 10: Plotting Error Rate vs K
plt.figure(figsize=(10,6))
plt.plot(k_range, error_rate, color='blue', linestyle='dashed', marker='o',
         markerfacecolor='red')
plt.title('Error Rate vs K Value')
plt.xlabel('K')
plt.ylabel('Error Rate')
plt.grid(True)
plt.show()

# Step 11: Best K
best_k = error_rate.index(min(error_rate)) + 1
print(f"Best K value: {best_k}")

# Step 12: Retrain with best K
best_model = KNeighborsClassifier(n_neighbors=best_k)
best_model.fit(X_train, y_train)
final_pred = best_model.predict(X_test)

print("Final Accuracy with best K:", accuracy_score(y_test, final_pred))
print("Confusion Matrix:\n", confusion_matrix(y_test, final_pred))
print("Classification Report:\n", classification_report(y_test, final_pred))

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Step 1: Create a simple DataFrame with missing values
data = {
    'Age': [25, 30, np.nan, 45, 50, np.nan, 35],
    'Salary': [50000, 60000, 55000, np.nan, 75000, 70000, np.nan]
}
df = pd.DataFrame(data)

print("Original DataFrame with missing values:\n", df)

# Step 2: Handle missing values (main method used: fill with mean)
df_filled = df.fillna(df.mean(numeric_only=True))

# --- Other handling methods (mentioned in comments):
# df_dropped = df.dropna()  # 1. Remove rows with any missing values
# df_filled_constant = df.fillna(0)  # 2. Replace all NaNs with a constant (e.g., 0)
# df_filled_ffill = df.fillna(method='ffill')  # 3. Forward fill the missing values

print("\nDataFrame after filling missing values with mean:\n", df_filled)

# Step 3: Scatter Plot (Age vs Salary)
plt.figure(figsize=(12, 5))

plt.subplot(1, 2, 1)
plt.scatter(df_filled['Age'], df_filled['Salary'], color='blue')
plt.title('Scatter Plot - Age vs Salary')
plt.xlabel('Age')
plt.ylabel('Salary')

# Step 4: Box Plot (for both Age and Salary)
plt.subplot(1, 2, 2)
df_filled.boxplot(column=['Age', 'Salary'])
plt.title('Box Plot')

plt.tight_layout()
plt.show()





